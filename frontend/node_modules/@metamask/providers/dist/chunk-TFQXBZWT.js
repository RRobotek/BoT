"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunk4WPMRSOHjs = require('./chunk-4WPMRSOH.js');


var _chunk732OO7W6js = require('./chunk-732OO7W6.js');





var _chunkHIKGM7AJjs = require('./chunk-HIKGM7AJ.js');


var _chunkALI4B7QIjs = require('./chunk-ALI4B7QI.js');

// src/MetaMaskInpageProvider.ts
var _rpcerrors = require('@metamask/rpc-errors');
var MetaMaskInpageProviderStreamName = "metamask-provider";
var MetaMaskInpageProvider = class extends _chunk732OO7W6js.AbstractStreamProvider {
  /**
   * Creates a new `MetaMaskInpageProvider`.
   *
   * @param connectionStream - A Node.js duplex stream.
   * @param options - An options bag.
   * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
   * Default: `metamask-provider`.
   * @param options.logger - The logging API to use. Default: `console`.
   * @param options.maxEventListeners - The maximum number of event
   * listeners. Default: 100.
   * @param options.shouldSendMetadata - Whether the provider should
   * send page metadata. Default: `true`.
   */
  constructor(connectionStream, {
    jsonRpcStreamName = MetaMaskInpageProviderStreamName,
    logger = console,
    maxEventListeners = 100,
    shouldSendMetadata
  } = {}) {
    super(connectionStream, {
      jsonRpcStreamName,
      logger,
      maxEventListeners,
      rpcMiddleware: _chunkHIKGM7AJjs.getDefaultExternalMiddleware.call(void 0, logger)
    });
    this._sentWarnings = {
      // methods
      enable: false,
      experimentalMethods: false,
      send: false,
      // events
      events: {
        close: false,
        data: false,
        notification: false
      }
    };
    this._initializeStateAsync();
    this.isMetaMask = true;
    this._sendSync = this._sendSync.bind(this);
    this.enable = this.enable.bind(this);
    this.send = this.send.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this._warnOfDeprecation = this._warnOfDeprecation.bind(this);
    this._metamask = this._getExperimentalApi();
    this._jsonRpcConnection.events.on("notification", (payload) => {
      const { method } = payload;
      if (_chunkHIKGM7AJjs.EMITTED_NOTIFICATIONS.includes(method)) {
        this.emit("data", payload);
        this.emit("notification", payload.params.result);
      }
    });
    if (shouldSendMetadata) {
      if (document.readyState === "complete") {
        _chunk4WPMRSOHjs.sendSiteMetadata.call(void 0, this._rpcEngine, this._log);
      } else {
        const domContentLoadedHandler = () => {
          _chunk4WPMRSOHjs.sendSiteMetadata.call(void 0, this._rpcEngine, this._log);
          window.removeEventListener(
            "DOMContentLoaded",
            domContentLoadedHandler
          );
        };
        window.addEventListener("DOMContentLoaded", domContentLoadedHandler);
      }
    }
  }
  //====================
  // Private Properties
  //====================
  get chainId() {
    throw new Error(_chunkALI4B7QIjs.messages_default.errors.invalidPropertyChainId());
  }
  get networkVersion() {
    throw new Error(_chunkALI4B7QIjs.messages_default.errors.invalidPropertyNetworkVersion());
  }
  get selectedAddress() {
    throw new Error(_chunkALI4B7QIjs.messages_default.errors.invalidPropertySelectedAddress());
  }
  //====================
  // Public Methods
  //====================
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param callback - The callback function.
   */
  sendAsync(payload, callback) {
    this._rpcRequest(payload, callback);
  }
  /**
   * We override the following event methods so that we can warn consumers
   * about deprecated events:
   * `addListener`, `on`, `once`, `prependListener`, `prependOnceListener`.
   */
  addListener(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.addListener(eventName, listener);
  }
  on(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.on(eventName, listener);
  }
  once(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.once(eventName, listener);
  }
  prependListener(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.prependListener(eventName, listener);
  }
  prependOnceListener(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.prependOnceListener(eventName, listener);
  }
  //====================
  // Private Methods
  //====================
  /**
   * Warns of deprecation for the given event, if applicable.
   *
   * @param eventName - The name of the event.
   */
  _warnOfDeprecation(eventName) {
    if (_optionalChain([this, 'access', _ => _._sentWarnings, 'optionalAccess', _2 => _2.events, 'access', _3 => _3[eventName]]) === false) {
      this._log.warn(_chunkALI4B7QIjs.messages_default.warnings.events[eventName]);
      this._sentWarnings.events[eventName] = true;
    }
  }
  //====================
  // Deprecated Methods
  //====================
  /**
   * Equivalent to: `ethereum.request('eth_requestAccounts')`.
   *
   * @deprecated Use request({ method: 'eth_requestAccounts' }) instead.
   * @returns A promise that resolves to an array of addresses.
   */
  async enable() {
    if (!this._sentWarnings.enable) {
      this._log.warn(_chunkALI4B7QIjs.messages_default.warnings.enableDeprecation);
      this._sentWarnings.enable = true;
    }
    return new Promise((resolve, reject) => {
      try {
        this._rpcRequest(
          { method: "eth_requestAccounts", params: [] },
          _chunkHIKGM7AJjs.getRpcPromiseCallback.call(void 0, resolve, reject)
        );
      } catch (error) {
        reject(error);
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  send(methodOrPayload, callbackOrArgs) {
    if (!this._sentWarnings.send) {
      this._log.warn(_chunkALI4B7QIjs.messages_default.warnings.sendDeprecation);
      this._sentWarnings.send = true;
    }
    if (typeof methodOrPayload === "string" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
      return new Promise((resolve, reject) => {
        try {
          this._rpcRequest(
            { method: methodOrPayload, params: callbackOrArgs },
            _chunkHIKGM7AJjs.getRpcPromiseCallback.call(void 0, resolve, reject, false)
          );
        } catch (error) {
          reject(error);
        }
      });
    } else if (methodOrPayload && typeof methodOrPayload === "object" && typeof callbackOrArgs === "function") {
      return this._rpcRequest(
        methodOrPayload,
        callbackOrArgs
      );
    }
    return this._sendSync(methodOrPayload);
  }
  /**
   * Internal backwards compatibility method, used in send.
   *
   * @param payload - A JSON-RPC request object.
   * @returns A JSON-RPC response object.
   * @deprecated
   */
  _sendSync(payload) {
    let result;
    switch (payload.method) {
      case "eth_accounts":
        result = super.selectedAddress ? [super.selectedAddress] : [];
        break;
      case "eth_coinbase":
        result = _nullishCoalesce(super.selectedAddress, () => ( null));
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(payload, _chunkHIKGM7AJjs.NOOP);
        result = true;
        break;
      default:
        throw new Error(_chunkALI4B7QIjs.messages_default.errors.unsupportedSync(payload.method));
    }
    return {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      result
    };
  }
  /**
   * Constructor helper.
   *
   * Gets the experimental _metamask API as Proxy, so that we can warn consumers
   * about its experimental nature.
   *
   * @returns The experimental _metamask API.
   */
  _getExperimentalApi() {
    return new Proxy(
      {
        /**
         * Determines if MetaMask is unlocked by the user.
         *
         * @returns Promise resolving to true if MetaMask is currently unlocked.
         */
        isUnlocked: async () => {
          if (!this._state.initialized) {
            await new Promise((resolve) => {
              this.on("_initialized", () => resolve());
            });
          }
          return this._state.isUnlocked;
        },
        /**
         * Make a batch RPC request.
         *
         * @param requests - The RPC requests to make.
         */
        requestBatch: async (requests) => {
          if (!Array.isArray(requests)) {
            throw _rpcerrors.rpcErrors.invalidRequest({
              message: "Batch requests must be made with an array of request objects.",
              data: requests
            });
          }
          return new Promise((resolve, reject) => {
            this._rpcRequest(requests, _chunkHIKGM7AJjs.getRpcPromiseCallback.call(void 0, resolve, reject));
          });
        }
      },
      {
        get: (obj, prop, ...args) => {
          if (!this._sentWarnings.experimentalMethods) {
            this._log.warn(_chunkALI4B7QIjs.messages_default.warnings.experimentalMethods);
            this._sentWarnings.experimentalMethods = true;
          }
          return Reflect.get(obj, prop, ...args);
        }
      }
    );
  }
};




exports.MetaMaskInpageProviderStreamName = MetaMaskInpageProviderStreamName; exports.MetaMaskInpageProvider = MetaMaskInpageProvider;
//# sourceMappingURL=chunk-TFQXBZWT.js.map