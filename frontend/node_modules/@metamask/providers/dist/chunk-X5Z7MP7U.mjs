import {
  sendSiteMetadata
} from "./chunk-4GWOPZBO.mjs";
import {
  AbstractStreamProvider
} from "./chunk-QKLSYLQW.mjs";
import {
  EMITTED_NOTIFICATIONS,
  NOOP,
  getDefaultExternalMiddleware,
  getRpcPromiseCallback
} from "./chunk-PXNIBUJU.mjs";
import {
  messages_default
} from "./chunk-XT5MFO3L.mjs";

// src/MetaMaskInpageProvider.ts
import { rpcErrors } from "@metamask/rpc-errors";
var MetaMaskInpageProviderStreamName = "metamask-provider";
var MetaMaskInpageProvider = class extends AbstractStreamProvider {
  /**
   * Creates a new `MetaMaskInpageProvider`.
   *
   * @param connectionStream - A Node.js duplex stream.
   * @param options - An options bag.
   * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
   * Default: `metamask-provider`.
   * @param options.logger - The logging API to use. Default: `console`.
   * @param options.maxEventListeners - The maximum number of event
   * listeners. Default: 100.
   * @param options.shouldSendMetadata - Whether the provider should
   * send page metadata. Default: `true`.
   */
  constructor(connectionStream, {
    jsonRpcStreamName = MetaMaskInpageProviderStreamName,
    logger = console,
    maxEventListeners = 100,
    shouldSendMetadata
  } = {}) {
    super(connectionStream, {
      jsonRpcStreamName,
      logger,
      maxEventListeners,
      rpcMiddleware: getDefaultExternalMiddleware(logger)
    });
    this._sentWarnings = {
      // methods
      enable: false,
      experimentalMethods: false,
      send: false,
      // events
      events: {
        close: false,
        data: false,
        notification: false
      }
    };
    this._initializeStateAsync();
    this.isMetaMask = true;
    this._sendSync = this._sendSync.bind(this);
    this.enable = this.enable.bind(this);
    this.send = this.send.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this._warnOfDeprecation = this._warnOfDeprecation.bind(this);
    this._metamask = this._getExperimentalApi();
    this._jsonRpcConnection.events.on("notification", (payload) => {
      const { method } = payload;
      if (EMITTED_NOTIFICATIONS.includes(method)) {
        this.emit("data", payload);
        this.emit("notification", payload.params.result);
      }
    });
    if (shouldSendMetadata) {
      if (document.readyState === "complete") {
        sendSiteMetadata(this._rpcEngine, this._log);
      } else {
        const domContentLoadedHandler = () => {
          sendSiteMetadata(this._rpcEngine, this._log);
          window.removeEventListener(
            "DOMContentLoaded",
            domContentLoadedHandler
          );
        };
        window.addEventListener("DOMContentLoaded", domContentLoadedHandler);
      }
    }
  }
  //====================
  // Private Properties
  //====================
  get chainId() {
    throw new Error(messages_default.errors.invalidPropertyChainId());
  }
  get networkVersion() {
    throw new Error(messages_default.errors.invalidPropertyNetworkVersion());
  }
  get selectedAddress() {
    throw new Error(messages_default.errors.invalidPropertySelectedAddress());
  }
  //====================
  // Public Methods
  //====================
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param callback - The callback function.
   */
  sendAsync(payload, callback) {
    this._rpcRequest(payload, callback);
  }
  /**
   * We override the following event methods so that we can warn consumers
   * about deprecated events:
   * `addListener`, `on`, `once`, `prependListener`, `prependOnceListener`.
   */
  addListener(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.addListener(eventName, listener);
  }
  on(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.on(eventName, listener);
  }
  once(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.once(eventName, listener);
  }
  prependListener(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.prependListener(eventName, listener);
  }
  prependOnceListener(eventName, listener) {
    this._warnOfDeprecation(eventName);
    return super.prependOnceListener(eventName, listener);
  }
  //====================
  // Private Methods
  //====================
  /**
   * Warns of deprecation for the given event, if applicable.
   *
   * @param eventName - The name of the event.
   */
  _warnOfDeprecation(eventName) {
    if (this._sentWarnings?.events[eventName] === false) {
      this._log.warn(messages_default.warnings.events[eventName]);
      this._sentWarnings.events[eventName] = true;
    }
  }
  //====================
  // Deprecated Methods
  //====================
  /**
   * Equivalent to: `ethereum.request('eth_requestAccounts')`.
   *
   * @deprecated Use request({ method: 'eth_requestAccounts' }) instead.
   * @returns A promise that resolves to an array of addresses.
   */
  async enable() {
    if (!this._sentWarnings.enable) {
      this._log.warn(messages_default.warnings.enableDeprecation);
      this._sentWarnings.enable = true;
    }
    return new Promise((resolve, reject) => {
      try {
        this._rpcRequest(
          { method: "eth_requestAccounts", params: [] },
          getRpcPromiseCallback(resolve, reject)
        );
      } catch (error) {
        reject(error);
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  send(methodOrPayload, callbackOrArgs) {
    if (!this._sentWarnings.send) {
      this._log.warn(messages_default.warnings.sendDeprecation);
      this._sentWarnings.send = true;
    }
    if (typeof methodOrPayload === "string" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
      return new Promise((resolve, reject) => {
        try {
          this._rpcRequest(
            { method: methodOrPayload, params: callbackOrArgs },
            getRpcPromiseCallback(resolve, reject, false)
          );
        } catch (error) {
          reject(error);
        }
      });
    } else if (methodOrPayload && typeof methodOrPayload === "object" && typeof callbackOrArgs === "function") {
      return this._rpcRequest(
        methodOrPayload,
        callbackOrArgs
      );
    }
    return this._sendSync(methodOrPayload);
  }
  /**
   * Internal backwards compatibility method, used in send.
   *
   * @param payload - A JSON-RPC request object.
   * @returns A JSON-RPC response object.
   * @deprecated
   */
  _sendSync(payload) {
    let result;
    switch (payload.method) {
      case "eth_accounts":
        result = super.selectedAddress ? [super.selectedAddress] : [];
        break;
      case "eth_coinbase":
        result = super.selectedAddress ?? null;
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(payload, NOOP);
        result = true;
        break;
      default:
        throw new Error(messages_default.errors.unsupportedSync(payload.method));
    }
    return {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      result
    };
  }
  /**
   * Constructor helper.
   *
   * Gets the experimental _metamask API as Proxy, so that we can warn consumers
   * about its experimental nature.
   *
   * @returns The experimental _metamask API.
   */
  _getExperimentalApi() {
    return new Proxy(
      {
        /**
         * Determines if MetaMask is unlocked by the user.
         *
         * @returns Promise resolving to true if MetaMask is currently unlocked.
         */
        isUnlocked: async () => {
          if (!this._state.initialized) {
            await new Promise((resolve) => {
              this.on("_initialized", () => resolve());
            });
          }
          return this._state.isUnlocked;
        },
        /**
         * Make a batch RPC request.
         *
         * @param requests - The RPC requests to make.
         */
        requestBatch: async (requests) => {
          if (!Array.isArray(requests)) {
            throw rpcErrors.invalidRequest({
              message: "Batch requests must be made with an array of request objects.",
              data: requests
            });
          }
          return new Promise((resolve, reject) => {
            this._rpcRequest(requests, getRpcPromiseCallback(resolve, reject));
          });
        }
      },
      {
        get: (obj, prop, ...args) => {
          if (!this._sentWarnings.experimentalMethods) {
            this._log.warn(messages_default.warnings.experimentalMethods);
            this._sentWarnings.experimentalMethods = true;
          }
          return Reflect.get(obj, prop, ...args);
        }
      }
    );
  }
};

export {
  MetaMaskInpageProviderStreamName,
  MetaMaskInpageProvider
};
//# sourceMappingURL=chunk-X5Z7MP7U.mjs.map